!> 内存管理

# 书籍链接
* [书籍链接](file:///media/deepin/670B-1B04/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/2021%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf)

# 内存管理概念

1. `内存管理`: 操作系统对内存的划分和动态分配,其功能有
    1. 内存空间的分配与回收: 操作系统来管理
    2. 地址转换: 用于转换程序中的逻辑地址和实际内存中的物理地址
    3. 内存空间的扩充: 利用虚拟存储技术或自动覆盖技术,逻辑上扩充内存
    4. 存储保护: 各个作业在各自存储空间运行,互不干扰
2. 程序的装入和链接: 将源程序变为内存可执行程序
    1. 编译: 将源代码编译为目标模块
    2. 链接: 将编译后的目标模块和库函数链接,形成装入模块
    3. 装入: 将装入模块装入内存运行
3. 程序链接方式:(都已提前编译好)
    1. 静态链接: 程序运行前将目标模块与库函数链接为装入模块,此后不拆开
    2. 装入时动态链接: 在将模块装入内存时,边装入,边进行目标模块和库函数的链接
    3. 运行时动态链接: 程序运行时再链接所需目标模块(目标模块易于修改与更新,且易于共享)
4. 装入模块装入内存的方式
    1. 绝对装入: 编译时知道程序装入内存的什么位置,则编译出带绝对地址的目标代码(程序逻辑地址与物理地址相同)  
        只适用单道程序环境  
    2. 可重定位装入: 多个目标模块的始址都是0,装入时需修改目标模块的相对地址为绝对地址.通常装入时一次完成  
        重定位: 装入过程修改目标程序的指令与数据  
        静态重定位: 装入时一次将所有目标模块的指令与数据都修改.装入内存,则必须分配所有需要空间,空间不够不装入.装入后不能在内存移动,不能再申请内存  
    3. 动态运行时装入: (动态重定位)目标模块装入内存后不修改其相对地址,程序执行时再将目标模块的相对地址转为绝对地址  
        动态重定位需要有`重定位寄存器`的支持  
        动态重定位可以将程序分配到不连续的存储区,程序运行前可载入部分代码来运行,运行期间可以动态申请分配内存,便于程序段共享  
5. 逻辑地址与物理地址
    1. 逻辑地址  
    程序的相对地址,每个目标模块都从0开始编址,合成装入模块后,所有的目标模块的逻辑地址就会合成`逻辑地址空间`  
    不同进程可以有相同逻辑地址  
    2. 物理地址  
    静态重定位和动态重定位在装入模块进内存时需要将逻辑地址转为物理地址(地址重定位)  
6. 内存保护: 需要保证用户进程不影响操作系统, 新用户进程不影响原用户进程.方法有
    1. CPU设置上下限寄存器,存放用户作业在主存的上下限地址.CPU访问地址时,则与其比较是否越界.  
    2. 使用重定位寄存器(基址寄存器)和界地址寄存器(限长寄存器).重定位寄存器放最小物理地址值,界地址寄存器放最大逻辑地址值.  
        先比较逻辑地址是否超过界地址寄存器,有地址越界,则地址错误,否则逻辑地址+重定位寄存器就是物理地址  
7. 覆盖与交换: 多道程序下扩充内存的方法
    1. 覆盖  
        将用户空间分为一个固定区和若干覆盖区,经常使用的放入固定区,其他部分分段放在外存,访问某段则候调入覆盖区覆盖当前段.  
        打破了必须将一个进程全部信息加入内存才能运行.更新只更新覆盖区的段  
    2. 交换(对换)  
        将等待进程从主存换到辅存,将就绪进程从辅存换到主存(可以参考第二章的`中级调度`)  
    3. 交换主要用于不同进程或作业(还在用),覆盖则用于同一程序或进程(已经不用)  
        如果主存放不下用户程序,现代操作系统则用`虚拟内存解决`  
8. 连续分配管理方式  
    用户程序的分配空间连续.包括`单一连续分配`, `固定分区分配`, `动态分区分配`  
    1. 单一连续分配  
        内存分为系统区和用户区,系统区在低地址,用户区只分配一道程序(用户区无需内存保护,一道程序不会有地址越界).  
        优点: 简单, 无外部碎片, 可用覆盖技术  
        缺点: 用于单用户单任务系统, 有内部碎片, 存储器利用率低  
    2. 固定分区分配  
        简单的多道程序存储管理方式.内存分为多个固定大小区域,每个区域装入一道作业  
        分区大小相等: 用于一台计算机控制多个相同对象,不灵活  
        分区大小不等: 大,中,小分区各有一些(有分区表,包含分区始址,大小,分配状态)  
        优点: 简单,无外部碎片  
        缺点: 大进程可能放不下(需要使用覆盖技术),小进程占用太多空间(有内部碎片, 存储利用率低),多进程无法共享一个存储区  
    3. 动态分区分配  
        也叫`可变分区分配`, 进程进入内存后动态建立符合进程大小的分区(分区数目与大小可变)  
        内存满后, 换出进程的位置放换入进程.  
        碎片使用`紧凑`解决(移动进程来合并碎片,需要动态重定位寄存器,类似windows的磁盘整理程序)  
        优点: 最开始内存利用率高
        缺点: 进程的交换会有大量外部碎片, 长期会降低内存利用率  
    4. 动态分区分配策略: (进程进入主存, 有多个分区可放进程, 应该放入哪一个)
        1. 首次适应(First Fit)  
            空闲分区以地址递增顺序链接, 放入第一个满足的分区  
        2. 最佳适应(Best Fit)  
            空闲分区以容量递增顺序链接, 放入第一个满足的分区  
        3. 最坏适应(Worst Fit),也加最大适应(Largest Fit)  
            空闲分区以容量递减顺序链接, 放入第一个满足的分区  
        4. 邻近适应(Next Fit),也叫循环首次适应算法  
            从上次查找结束的位置开始查找, 放入第一个满足的分区. 到最后一个则返回开头.  
        5. 评价  
            首次适应算法最佳, 使用数组而没有使用链表.但低地址有很多小空闲分区,每次分配都经过这里,增加了查找开销  
            邻近适应算法, 内存尾碎片更多, 比首次适应算法效果差.  
            最佳适应算法, 外部碎片多, 性能差.  
            最坏适应算法, 大内存块少, 性能差.  
            FF > BF > WF
9. 非连续分配管理方式  
    用户程序可以分散的装入不相邻的内存空间.需要用表存储数据映射地址,故存储密度低于连续分配管理方式  
    根据分区大小是否固定分为: `分页存储管理方式`和`分段存储管理方式`  
    根据分页存储管理方式是否把所有页面加入内存分为: `基本分页存储管理方式`和`请求分页存储管理方式`  
10. 存储密度  
```tex
\small
\displaystyle
存储密度 = \frac{结点数据占用大小}{结点结构占用大小}
```
11. 分页存储的一些名词  
    * 页: (也叫页面)进程中的块  
    * 页框: (也叫页帧)内存中的块  
    * 块: 外存中的块(外存也划分为同样的单位)  
    * 地址结构: 进程某数据的逻辑地址划分的结构.包括页号和页内偏移量  
        如果逻辑地址为32位,低12位为页内偏移量,高20位为页号,则一个页最大为2^12B,页数最多为2^20个  
        地址结构(也就是逻辑地址结构)决定了虚拟内存的寻址空间大小
    * 页表: 记录一个进程的每个页面页号在内存中对应的物理块号.页表一般放到内存中.  
        页表由页表项组成  
        一个数据的物理地址 = 页表项的物理块号对应地址 + 地址结构的页内偏移量  
    * 页表项: 由页号和块号组成.页号对应进程的每一页,块号对应内存中的物理块地址  
        32位逻辑地址空间, 字节编址单位, 逻辑地址空间编址后长度就是4B  
        一页4KB,逻辑地址结构中的页面偏移量需要占用12位,剩下的20位用作页号存储,2^20 = 1M  
        如果页号存储换成字节为单位, [20 / 8] = 3, 存储页号的页表项应大于等于3B(这里默认页表项只放页号)  
        如果一页4KB, 页表项4B, 则一页可存放1K个页表项  
        ```tex
        \small
        \displaystyle
        2^20 = 1M, 则log_{2}1M = 20
        ```
    * 页表寄存器
        存放`页表在内存的起始地址`和`页表长度`  
        
12. 基本分页存储管理方式  
    * 主存分为大小相等且固定的小块(主存基本单位),进程也以块为单位划分,以块为单位申请主存空间  
    * 分页管理没有外部碎片,只在进程申请的最后一个不完整的主存块有内部碎片(平均每个进程半个块大小的内部碎片, 也叫页内碎片)  
    * 页面大小为2的整数幂,且页面大小应该适中(页面大小小,页多,页表变长,占用内存,增加硬件地址转换开销;页面大小大,页内碎片增多,降低内存利用率)  
    * 地址变换机构: 将逻辑地址转换为内存的物理地址(借助页表实现)  
    * 进程运行,将进程控制块中存的页表寄存器的页表起始地址和页表长度放到寄存器
    * 逻辑地址到物理地址的转换过程(逻辑地址并不是指一个页的首地址,而是一个数据的首地址)
        0. 逻辑地址: A, 物理地址: E, 页面大小: L, 页号: P, 页表长度: M, 页内偏移量: W
            页表始址: F
        1. P = A / L, W = A % L
        2. P < M, 则要找的页在内存中,否则会有越界中断
        3. P页的页表项首地址 = F + P * 页表项长度(页地址占用的存储空间长度), 获取页表项内容中的物理块号b
        4. E = b * L + W,得到物理地址
    * 页式管理只需要给出逻辑地址就能找到物理地址(页大小固定,页表始址,页表项长度固定).地址空间为`一维`
13. 分页管理的问题
    1. 每次访存都需要地址转换(地址转换需要很快,否则影响访存速度)
    2. 每个进程引入页表,占用内存空间(页表大, 则内存空间利用率变小) 
14. 页表全部放在内存,取一个数据需访存两次(第一次访问页表取物理地址,第二次获取实际数据)
15. 快表: (相连存储器, TLB), `存放若干页表项`, 加速地址转换(主存页表叫做慢表).  
    * 在某些处理机下,快慢表可同时查找,快表查找成功,则停止慢表查找  
    * 有快表,先从快表中匹配页号,匹配成功则直接获取页表项转换物理地址,然后访存.匹配失败再从内存获取页表项,并把页表项加入快表,再访存.快表满后,则按算法替换页表项  
    * 快表命中率为90%以上, 基于`局部性原理`  
16. 两级页表  
    * 有了页表之后, 进程加载部分页即可运行(所有的页或页表并不同时使用)  
    * 如果页表特别多,且页表不连续,那么所有的页表就需要再加一个索引表,找某个页表也更方便,也就会用到二级页表(页表的页表)  
    * 二级页表也是顶级页表, 最多只能有一个页面  
    * 建立`多级页表`就是为了建立索引,`不用浪费主存存储无用页表项`,也不`用盲目顺序查找页表项`  
    * 两级页表的逻辑地址结构包括一级页号, 二级页号, 页内偏移量  
        一页存储1K个页表项,需要10位,高10位存储每个一级页表的第几个页表项, 中十位存储获取二级页表的第几个页表项,剩下的12位作为页内偏移量  
        每个页表项存储了页号和页或页表对应的物理块号
17. 逻辑地址结构存的是逻辑地址, 页表项存的是页号与块号对应关系
18. 基本分段存储管理方式
    * 分页存储可以提高内存利用率, 且分页存储通过硬件实现(用户透明)
    * 分段存储是出于对程序的考虑,按进程的自然段划分逻辑空间.  
        若用户进程由主程序,两个子程序,栈,一段数据组成,则用户进程划分五段.  
        段内需要连续,段间不需要连续  
        分段存储利于代码和数据共享  
    * 分段
        * 逻辑地址结构由`段号`和`段内偏移量`组成
        * `段号`和`段内偏移量`需要用户给出,所以地址空间是二维的  
            分页存储的页内偏移量可以算出来,给一个地址即可,分段不可以,需要两个都给
        * 分页存储,逻辑地址的页号与页内偏移量对用户透明  
            分段存储,段号与段内偏移量需要用户提供(可由编译程序完成)
    * 段表
        * 段表由段表项组成
        * 段表项的结构是: `段号`, `段长`, `本段在主存的始址`
    * 逻辑地址到物理地址的转换过程
        0. 逻辑地址: A(段号: S, 段内偏移量: W), 段表始址:F, 段表长: M  
            段表项(段号:S, 段长:C, 段基址: b), 物理地址: E
        1. 得到逻辑地址的段号S, 如果S < M, 则继续执行, 否则越界中断
        2. 得到段表项始址 = F + S * 段表项长度, 找到段长C, 如果W < M则获得段物理基址b,否则越界中断
        3. 物理地址E = b + W
    * 段共享和保护  
        共享: 两个作业段表项指向同一个物理段地址. 一个作业正在读该段, 别的作业则不能修改该段  
        纯代码: 不能修改的代码(不是临界资源,相当于修饰final),也叫`可重入代码`  
        保护: 包括`存取控制保护`和`地址越界保护`(段号与寄存器段号比较,段偏移量与段表项的段长比较)  
19. 段页式管理方式
    * 页式存储提高内存利用率, 段式存储利于代码与数据共享
    * 形式: 作业先分段,然后每段分成大小固定的页  
    * 逻辑地址结构: 段号S, 页号P, 页内偏移量W
    * 地址转换所需数据结构
        * 段表项: 段号, 页表长度, 页表始址
        * 页表项: 页号, 块号 
        * 段表寄存器: (硬件结构)段表始址, 段长
    * 逻辑地址到物理地址
        1. 获取逻辑地址的段号,判断段号是否大于段表长度,不大于则通过段表获取段表项,大于则地址越界
        2. 从页表项获取页表长度,从逻辑地址获取页号,页号不大于页表长度则获取页表项,大于则地址越界
        3. 从页表项获取块号,加上页面偏移量获取物理地址
20. 段表寄存器和页表寄存器可以帮助段表或页表寻址,也可帮助判断是否越界
21. 一个进程的段表只有一个,页表可能有多个
22. 段页式管理的地址空间也是二维的,需要指出查询哪个段和段内所查询逻辑地址
23. 段页式管理需要访存三次(获取段表项,获取页表项,获取数据), 可加快表加速查找  
24. 内存管理可以更好的支持多道程序并发
25. 多级页表可以解决逻辑地址空间过大,页表太长的问题,但是引入多级页表,会增加访存次数,降低程序执行效率

# 虚拟内存管理
1. 传统存储管理方式的特征: 
    * 一次性: 作业一次全部装入内存才能运行, 问题有
        * 作业很大无法全部装入,则无法运行
        * 大量作业运行时,内存无法装入所有作业,多道程序度下降
    * 驻留性: 进程进入内存,运行完之前一直留在内存.如遇IO阻塞,则长期等待
2. 局部性原理
    * 时间局部性: 当前程序中的指令或数据被访问后,不久可能再次访问(程序中有大量循环操作)  
        将近来使用的指令和数据保存到高速缓存,使用层次结构实现
    * 空间局部性: 程序一段时间内访问的地址可能在一定范围内(指令顺序存放并执行, 数据可能是数组等情况)  
3. 高速缓存技术包括`快表`, `页高速缓存`, `虚拟内存技术`,其都依赖`局部性原理`
4. 虚拟内存建立了`内存-外存`两级存储器结构,利用局部性原理实现高速缓存
5. 虚拟存储器
    * 基于`局部性原理`,将程序一部分调入内存.程序即可执行.访问数据不存在,则从外存调入内存. 暂时不用的数据由内存调到外存
    * 虚拟存储器比实际内存大得多,是因为系统实现了`部分装入`,`请求调入`和`置换功能`
    * 虚拟存储器大小由计算机地址结构决定(不是内存与外存简单相加)
    * 主要特征
        1. 多次性(程序数据可被多次调入内存, 无需一次全部调入)
        2. 对换性(作业运行时期可以换入换出,例如阻塞时)
        3. 虚拟性(逻辑上扩充了内存容量)
6. 虚拟内存的实现
    * 建立在`离散分配内存`的方式上
    * 实现方式
        1. 请求分页存储管理
        2. 请求分段存储管理
        3. 请求段页式存储管理
7. 请求分页管理方式
    * 基本分页系统将所有页都加载到内存,请求分页系统可加载部分页到内存
    * `请求分页`是一种`实现虚拟存储器`的方法
    * 可以将需要的页调入(请求调页功能),将不用的页调出(页面置换功能)
    * 所需支持
        1. 硬件,一定容量的内存和外存
        2. 页表,段表作为主要数据结构
        3. 缺页中断机构(用于访问的数据不在内存时的中断)
        4. 地址变换机构,逻辑地址与物理地址的转换
    * 页表机制
        * 请求页表项结构: 页号, 物理块号, 状态位P(), 访问字段A(), 修改位M, 外存地址
        * 状态位: 标识该页是否调入内存
        * 访问字段: 记录一段时间被访问或未被访问的次数,用于页面置换
        * 修改位: 标识该页调入内存后是否修改过
        * 外存地址: 该页在外存的地址,一般是物理块号
    * 缺页中断机构
        * 进程访问的页不在内存, 产生缺页中断, 进程阻塞,内存有空闲块则将页调入,内存无空闲块,则用页面置换算法  
            置换时如果该页修改过,则覆写外存
        * 缺页中断是指令执行期间产生和处理中断(`内部中断`),不是指令执行完后产生和处理中断
        * 一条指令执行期间可多次产生缺页中断
    * 地址变换机构
        * 从页表项状态位判断页是否在内存
        * 在则修改请求访问页表项的访问字段(页被改过还需调整修改位),用物理块号得到物理地址
        * 不在则从外存调页.
        * 内存满则使用置换算法调页,页被修改则需覆写外存,内存有空闲则直接调入,然后修改页表项状态位和外存地址
8. 页面置换算法
    * 好的页面置换算法应有较低页面更换频率,即,将以后不会访问或长时间不访问的页调出
    * 常见置换算法
        1. 最佳置换算法(OPT)  
            换出未来不再访问或长时间不访问页面  
            无法实现, 因无法确定未来哪个页面长时间不访问,但可用于评价其他算法  
            如果给出了页使用队列,则可看哪个页最后使用,则将其换出  
            最长时间不被访问和以后被访问次数最小不一样
        2. 先进先出置换算法(FIFO)  
            换出最先进内存的页面  
            可以把页面链成队列, 指针指向队首, 每次换出第一个页面  
            FIFO算法可能会有物理块增加,缺页次数也增大的情况(Belady异常)  
            只有FIFO算法有Belady异常,LRU和OPT不会有
        3. 最近最久未使用置换算法(LRU)  
            换出最近最长时间未访问的页面(过去一段时间不访问,接下来一段时间可能也不访问)  
            使用请求页表项的访问字段记录最近一次访问是第几次前.  
            每请求一次页,所有页表项的访问字段加1,被请求页的页表项的访问字段置0  
            换出访问字段值最大的页  
            LRU是向前看的(看以前的页哪个用的少), OPT是向后看的(看后边哪个页用的少)  
            LRU性能较好,但需要寄存器和栈支持,性能接近OPT,实现较困难,开销大  
            LRU是堆栈算法,FIFO是队列算法
        4. 时钟置换算法(CLOCK), 也叫最近未用算法(NRU)  
            每个页表项放一个使用位, 一个修改位(附加位), 1是使用/修改过, 0是未使用/修改过  
            性能接近LRU算法  
            使用了某页,则该页使用位置1,并将指针后移一个  
            CLOCK算法置换过程:  
            (1) 找到使用位为0的页换出(每个跳过的帧,使用位置0)  
            (2) 上边失败,则再次执行1
            (3) 换出并换入页面后,该页使用位置1,并将指针后移一个  
            改进型CLOCK算法置换过程:  
            (1) 从指针当前位置,扫描帧缓冲区换掉第一个未使用过也未修改过的页(不修改使用位)  
            (2) 上边失败,则找第一个未使用过但修改过的页换出(每个跳过的帧,使用位置0)  
            (3) 上边失败,则重复第一步,第一步失败,则重复第二步  
            (4) 换出并换入页面后,该页使用位置1,并将指针后移一个  
            改进型CLOCK算法先选未修改过的页换出, 节省了时间(修改过的页换出需覆写)  
9. 页面分配策略
    * 驻留集: 给一个进程分配的物理页框的集合(请求分页只调入进程部分页,所以需要决定分配几个页框)
    * 驻留集分配数量的考虑点:  
        * 每个进程分的页框少,内存进程就多,提高了处理机利用率  
        * 每个进程分的页框少,缺页率高  
        * 每个进程分的页框多,基于局部性原理,某些进程的缺页率变化不大  
    * 三种分配策略
        * 固定分配局部置换  
            每个进程分配一定页框,运行期间页框数不变,缺页则直接页面置换  
            不易确定每个进程页框分配数目(太少会频繁缺页中断, 太多会降低CPU和其他资源利用率)
        * 可变分配全局置换(最容易实现)  
            每个进程分配一定页框, 操作系统持有空闲页框队列  
            进程缺页,操作系统则给该进程一个页框装入新页  
            比固定分配局部置换灵活,但给进程盲目增加物理块,多道程序并发能力下降  
        * 可变分配局部置换  
            每个进程分配一定页框,缺页则页面置换  
            若频繁缺页,系统为其分配物理块,知道缺页率趋于适当程度  
            缺页率低也可减少物理块  
            该方法可以保证进程不会过多调页(缺页率高),也保证多道程序并发能力.但复杂,开销大
    * 调入页面时机
        * 预调页策略  
            将预计不久会访问的页面调入内存(一页一页调比较低效,一次调入一批但大部分不用也低效)  
            预调页成功率为50%, 主要用于进程首次调用(由程序员指出调用哪些)  
        * 请求调页策略(虚拟存储器多用此策略)  
            缺页时由系统调入内存  
            调入的页一定会访问,容易实现,调入调出过多则IO开销大  
    * 从何处调入页面
        * 请求分页系统的外存分为`存放文件的文件区`和`存放对换页面的对换区`  
            对换区用连续分配方式, 文件区用离散分配方式(故对换区文件IO速度比文件区快)  
        * 调入页面的三种情况  
            (1) 系统有足够对换空间,则全部从对换区调页(速度快),进程运行前需将进程有关文件从文件区复制到对换区  
            (2) 系统对换空间不足,则不会修改的文件从文件区调入,调出时无需换出,被修改的文件换到对换区,调入时从对换区调入  
            (3) UNIX方式,进程有关文件在文件区,未调入过的页面都在文件区,调出的页面放到对换区(下次调入该页则从对换区调入)  
10. 抖动: 也叫颠簸. 刚刚换入或换出的页面就要换出或换入,会有缺页中断  
    * 进程的换页时间多于执行时间,进程就在颠簸
11. 工作集: 进程某段时间内访问的页面集合(可用局部性原理以最近访问的页面确定工作集)  
    * 工作窗口: 使用过的页面数量  
    * 局部性好的程序,工作集大小会比工作窗口小很多  
    * 分配给程序的物理块数小于工作集大小,则可能频繁缺页, 故分给进程的物理块数(驻留集大小)要大于工作集
    * 工作集内的页面要调入驻留集,工作集外的页面可以换出驻留集(用的可能少),
    * 若有其他空闲物理块可以调入一个进程增加多道并发能力,若进程工作集之和超过物理块总数,操作系统会暂停一个进程,将页面分给其他进程,防止抖动
12. 地址翻译:  

?> _TODO_ (与计算机组成原理相联系,日后再看.PDF212页)

13. 虚拟内存 <= 内存 + 外存, 虚拟内存 <= 计算机地址位数能容纳最大空间(32位地址,一个地址存1B,则计算机地址最大容量为4GB, 虚拟内存大于这个大小则地址也无法访问,故浪费了空间)
14. 虚拟内存使用外存扩充了内存空间,调页会增加平均访存时间,页面置换算法不合理则大大降低系统性能
15. 页大小由硬件实现,系统则只能有一种大小的页
16. 分页不易`共享`和`动态链接`,分段容易`共享`和`动态链接`
17. 分页是按物理结构划分,分段是按逻辑结构划分