!> IO管理

# 书籍链接
* [书籍链接,300](file:///media/deepin/670B-1B04/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/2021%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf)

# IO管理概述
1. IO设备按使用特性分类
    1. 人体交互类外设: 打印机,显示器,鼠标,键盘等.数据交互速度慢,通常以字节为单位交换数据
    2. 存储设备: 磁盘,磁带,光盘等.数据交互速度较快,通常以多字节组成的块为单位交换数据
    3. 网络通信设备: 网络接口,调制解调器等.速度介于人体交互外设和存储设备
2. IO设备按传输速率分类
    1. 低速设备: 键盘,鼠标等,速度为每秒几字节到几百字节
    2. 中速设备: 行式打印机,激光打印机等,速度为每秒几千字节到几万字节
    3. 高速设备: 磁带,磁盘,光盘,速度为每秒几百KB到几MB的设备
3. IO设备按信息交换单位分类
    1. 块设备: 信息存取以数据块为单位(存取数据块的设备叫块设备).是有结构设备,如磁盘.速率较高,可寻址
    2. 字符设备: 信息存取以字符为单位,是无结构设备,终端机,打印机等(数据输入输出设备).速率较低,不可寻址
4. 外围设备与内存的IO方式
    1. 程序直接控制方式  
        CPU告诉外设要读数据,外设准备数据的同时,需CPU不断检查外设是否准备好数据,外设无法通知CPU已经有数据了(CPU无中断机构)  
        实现简单,但CPU与外设串行工作,造成了CPU资源极大浪费  
    2. 中断驱动方式  
        CPU告诉外设要读数据后可以做其他工作,外设准备好数据可打断CPU的运行并请求服务.CPU即可读数据  
        数据在外设和内存之间的传输需要经过CPU,每次的中断处理也会消耗CPU时间
    3. DMA方式(Direct Memory Access,直接存储器存取)  
        所需寄存器:
        1. 命令状态寄存器(CR): 存放CPU的IO命令,设备状态
        2. 内存地址寄存器(MAR): 存数据到内存的起始地址或从内存输出的内存源地址
        3. 数据寄存器(DR): 暂存设备与内存交互的数据
        4. 数据计数器(DC): 存放本次传送的字(节)数
        在外设和内存之间开辟直接数据交换通路  
        特点: 基本单位是数据块; 数据由外设和内存直接相互传送; 数据块传送的开始或结束需要CPU干预,中间传送由DMA控制  
        CPU收到外设的DMA请求,CPU启动DMA,然后做其他工作.DMA进行外设与存储器的数据块传送,每次传送一个字.数据块传送完成,DMA发送中断信号给处理器  
        中断驱动方式在每个数据传输时都要中断CPU,DMA方式在一批数据(一个数据块)传送完毕才中断CPU  
        中断驱动方式的数据传送在中断处理时由CPU控制完成,DMA方式的数据传输由DMA控制  
    4. 通道控制方式  
        IO通道是专门负责输入输出的处理机  
        可以实现读写一组数据块时才由CPU干预  
        可使CPU,通道,外设之间并行工作  
        CPU发送给通道指令, 通道根据指令从内存获取通道程序的首地址和外设ID,通道执行通道程序进行外设与内存的一组数据块的交互, 传输完成后中断CPU  
        通道与CPU区别: 通道指令单一,没有自己的内存,通道程序放在主机内存中  
        通道与DMA区别: DMA由CPU控制传输数据块大小与传输内存位置,通道则由通道控制传输数据块大小和传输内存位置;一个DMA对应一个设备与内存传递数据,一个通道可对应多个设备与内存传递数据  
5. IO子系统层次结构(IO软件结构)
    将系统IO功能组成一系列层次,每层利用下层提供的服务.层间的接口保持不变.
    | IO系统层次结构 |
    | :-----------:|  
    | 用户层IO软件  |
    | 设备独立性软件 |
    | 设备驱动程序   |
    | 中断处理程序   |
    | 硬件         |

    1. 用户层IO软件  
        实现与用户交互的接口  
        大部分IO软件都在操作系统内部,少部分在用户层.用户层IO软件需要系统调用获取IO服务  
    2. 设备独立性软件  
        实现用户程序与设备驱动器的统一接口,设备命令等,也为设备管理和数据传送提供必要存储空间  
        设备独立性也叫设备无关性,应用程序可独立于具体物理设备.  
        为实现设备独立性引入了`逻辑设备`和`物理设备`  
        应用程序使用逻辑设备名请求某类设备, 系统执行时将逻辑设备名映射为物理设备名  
        逻辑设备名好处: 设备分配灵活;易于IO重定向(应用程序不变,设备可以是另一个)  
        设备独立性软件主要功能: 执行所有设备公有操作(设备分配回收,逻辑设备名与物理设备名映射);向用户层(文件层)提供统一接口  
    3. 设备驱动程序  
        与硬件相关, 实现系统对设备发出的指令, 实现IO进程与设备的通信  
        提供给用户程序标准接口,设备差别被驱动程序封装,屏蔽掉设备差异  
    4. 中断处理程序  
        保护被中断进程的CPU环境,转入中断处理程序处理,处理完恢复中断现场,返回中断进程  
        在操作系统底层,对用户屏蔽  
    5. 硬件设备  
        IO设备一般包括机械部件(设备本身)和电子部件(设备控制器,适配器,主板扩充槽的电路板)  
        设备控制器通过寄存器与CPU通信(寄存器可放在内存,叫做内存映像IO,也可以使用IO专用地址,寄存器独立编址)  
        操作系统给控制器寄存器写命令字执行IO, 控制器可自行处理IO操作,执行完毕后控制器给CPU发送中断信号,CPU从控制器寄存器获取设备状态及执行结果  
        (设备控制器组成可以看305页)  
    6. 用户读取某设备内容流程  
        用户通过调用操作系统read命令(使用了用户层IO软件),由设备独立性软件解析,交给不同设备驱动程序(不同设备的read命令可能有差别,磁盘与打印机就不同)  
        设备驱动程序将read指令解析为设备可用指令,然后执行中断处理程序,执行read命令  
        命令到达硬件,硬件按照命令完成功能
6. IO管理要完成的功能
    1. 状态跟踪: 获取外设状态
    2. 设备存取: 存取设备数据
    3. 设备分配: 多用户下分配和回收设备
    4. 设备控制: 设备的驱动,完成和故障中断处理

# IO核心子系统
1. IO子系统  
    是操作系统的子系统  
    IO设备种类繁多,功能和传输速度差异大,需要多种方法进行设备控制  
    IO子系统提供了IO调度,缓冲与高速缓存,设备分配与回收,假脱机,设备保护,差错处理  
2. IO调度  
    使用好的顺序处理IO请求,使进程公平的访问设备,减少IO平均等待时间  
    每个设备都有一个请求队列.设备进行IO处理时,新请求则加到请求队列,并由IO调度重新安排队列顺序  
    磁盘调度算法也是IO调度的一种  
3. 磁盘高速缓存  
    在内存暂存磁盘一系列盘块信息(逻辑上属于磁盘,物理上属于内存), 可以提高磁盘IO速度  
    磁盘高速缓存可以在内存开辟一个固定空间作为高速缓存,也可将未利用的内存空间作为缓冲池,供请求分页系统和磁盘IO共享  
4. 缓冲区  
    缓冲区非空,不能写入数据,只能读出数据;缓冲区不为空,需要写满缓冲区才能读出数据  
    引入缓冲区目的  
    * 缓和CPU与IO速度不匹配矛盾
    * 减少CPU中断频率,放宽对CPU中断响应时间限制
    * 解决基本数据单元大小(数据粒度)不匹配问题
    * 提高CPU与IO设备并行性  

    实现方法
    * 使用硬件缓冲器(成本高,只用于关键部位)
    * 采用缓冲区(位于内存)  
    
    根据缓冲器个数分类  
    * 单缓冲: 设备和处理机之间设置一个缓冲区.
    ```dot
    digraph demo{
        node [
            shape = record;
        ];
        edge [
            color = "#ff5500";
        ]
        graph [
            label = "有缓冲区的处理简图";
            rankdir = LR;
        ];

        disk [label = "磁盘"];
        buffer [label = "缓冲区"];
        workspace [label = "工作区"];
        cpu [label = "CPU"];

        disk -> buffer [label = "用时T"];
        buffer -> workspace [label = "用时M"];
        workspace -> cpu [label = "用时C"];
    }
    ```  
    最开始工作区满,缓冲区空,工作区大小等于缓冲区.  
    若T > C, CPU处理完工作区数据用时C,磁盘填充数据到缓冲区用时T,并行用时T,缓冲区填充数据到工作区用时M,总用时T+M  
    若T < C, CPU处理完工作区数据用时C,磁盘填充数据到缓冲区用时T,并行用时C,缓冲区填充数据到工作区用时M,总用时C+M  
    故单缓冲区处理每块数据用时max(C, T) + M
    * 双缓冲: 
    设备先向缓冲区1填数据,填满后给缓冲区2填数据,用户区从缓冲区1获得的数据被处理完,就从缓冲区2获取数据来处理(缓冲区2需已装满)  
    提高了处理机和输入设备并行操作的程度  
    ```dot
    digraph demo{
        node [
            shape = record;
        ];
        edge [
            color = "#ff5500";
        ]
        graph [
            label = "有双缓冲区的处理简图";
            rankdir = LR;
        ];

        disk [label = "磁盘"];
        buffer1 [label = "缓冲区1"];
        buffer2 [label = "缓冲区2"];
        workspace [label = "工作区"];
        cpu [label = "CPU"];

        disk -> buffer1 [label = "用时T"];
        buffer1 -> workspace [label = "用时M"];
        disk -> buffer2 [label = "用时T"];
        buffer2 -> workspace [label = "用时M"];
        workspace -> cpu [label = "用时C"];
    }
    ```  
    最开始工作区空,缓冲区1空,缓冲区2满,工作区大小等于缓冲区.  
    若T < C + M.工作区充满数据,缓冲区2还没充满;缓冲区2充满,工作区数据还未处理完,此时磁盘暂停填入数据;工作区数据处理完则一个流程结束.处理一块数据用时C + M  
    若T > C + M,工作区充满数据并处理完,缓冲区2还没充满;缓冲区2充满,则一个流程结束,用时T  
    故双缓冲区处理每块数据用时max(C + M, T)  
    则M + C < T,可使块设备连续输入;M + C > T,则可使CPU不必等待设备输入  
    字符设备,使用行输入方式,使用双缓冲,输入第一行后,CPU处理,则可同时输入第二行;使用单缓冲,输入第一行后,需CPU取完数据才能输入第二行  
    两台机器通信仪配置了均单缓冲,任意时刻只能单向传输数据;若双向数据传输,则两个机器均需设置两个缓冲区(用于发送与接收)  
    * 循环缓冲  
    有多个大小相等的缓冲区,每个缓冲区有指针指向下一个缓冲区,最后一个缓冲区指针指向第一个缓冲区  
    循环缓冲用于输入输出时,需两个指针in和out,  
    输入时,in指向第一个空缓冲区,需要数据时,则out指向第一个满缓冲区  
    输出时,out指向第一个满缓冲区,填入数据时,in指向第一个空缓冲区  
    * 缓冲池  
    由多个系统公用的缓冲区组成  
    缓冲区的队列分类: 空缓冲队列, 装满输入数据的缓冲队列(输入队列), 装满输出数据的缓冲队列(输出队列)  
    缓冲区还应细分为收容输入数据的工作缓冲区,提取输入数据的工作缓冲区,收容输出数据的工作缓冲区,提取输出数据的工作缓冲区  
    输入进程输入数据,从空缓冲队列获取一个缓冲区作为收容输入数据的工作缓冲区,填满后挂到输入队列.进程需要输入数据,从输入队列获取一个缓冲区作为提取输入数据的工作缓冲区.取完数据则将缓冲区挂到空缓冲队列.  
    输出进程输出数据,从空缓冲队列获取一个缓冲区作为收容输出数据的工作缓冲区,填满后挂到输出队列.进程需要输出数据,从输出队列获取一个缓冲区作为提取输出数据的工作缓冲区,取完数据则将缓冲区挂到空缓冲队列.  
5. 高速缓存与缓冲区的对比  
    高速缓存和缓冲区速度都在高速设备和低速设备之间  
    高速缓存的数据是低速设备的拷贝,高速缓存需要的数据没有,则需访问低速设备  
    缓冲区存放低速设备和高速设备交互的数据,不一定有备份,最后会传递给对方.高速设备与低速设备通信都要用缓冲区,高速设备永远不会直接访问低速设备.  
6. 设备分配  
    根据用户IO请求分配所需设备,分配需要尽可能让设备忙起来,还要避免死锁  
    设备一般分为`独占设备`,`共享设备`,`虚拟设备`  
    独占设备: 申请设备时,若设备空闲,则独占,其他进程不能申请使用,等到设备被释放其他进程才能申请使用(如打印机).设备利用率低  
    共享设备: 如磁盘IO操作各个进程可以分时交替进行  
    虚拟设备: 以SPOOLing方式(假脱机IO技术)使用外部设备  
7. SPOOLing技术是用空间换时间,请求分页调度算法用时间换空间  
8. 设备分配的数据结构  
    设备控制表(DCT Device Control Table): 表征一个设备,每个表项是设备的各个属性(需要有控制器表指针,DCT与COCT一一对应)  
    控制器控制表(COCT Controller Control Table): 设备控制器与内存交换数据使用通道,故须有通道控制表指针,  
    通道控制表(CHCT Channel Control Table): 一个通道可为多个设备控制器服务.一个通道控制表可以指向多个控制器控制表.故CHCT与COCT为一对多  
    系统设备表(SDT System Device Table): 整个系统一张,记录连接到系统的物理设备情况.一个物理设备一个表目  
9. 设备分配考虑因素: IO设备固有属性, IO设备分配算法, IO设备分配安全性, IO设备独立性
10. 分配总原则: 充分发挥设备使用效率,避免造成死锁,将用户程序与具体设备分开
11. 设备分配分为`静态分配`和`动态分配`  
    静态分配: 作业开始前,分配好全部设备, 用于独占设备.静态分配不符合分配总原则  
    动态分配: 根据系统请求分配. 可以提高设备利用率, 但分配算法不当,会造成死锁.  
12. 动态设备分配算法: 先请求先分配, 优先级高者优先  
    独占设备可以采用动态分配方式,也可以采用静态分配方式.一般用静态分配方式.  
    共享设备可被多个进程共享,用动态分配方式.每个IO传输单位时间被一个进程占有.
13. 设备分配的安全性: 避免设备分配中发生进程死锁  
    安全分配方式: 进程IO请求后进入阻塞态,IO完成后唤醒.阻塞后不请求资源,不保持资源.不会造成进程死锁,但CPU和IO设备串行工作(对同一进程而言)  
    不安全分配方式: 进程IO请求后继续运行,仍需要时继续发出IO请求.若设备被占用,则进入阻塞态. 一个进程可操作多个设备,加快进程推进.但可能有进程死锁  
14. 设备独立性: 应用程序独立于具体物理设备. 提高了设备分配灵活性和设备利用率, 方便IO重定向  
15. 为实现设备独立性,应用程序使用逻辑设备名请求某设备.逻辑设备名映射在逻辑设备表中(LUT Logical Unit Table)
16. 逻辑设备表的建立: 整个系统一张逻辑设备表, 不能有相同逻辑设备名,适用于单用户系统;每个用户设置一张逻辑设备表
17. SPOOLing技术(假脱机技术): 缓和CPU的高速型和IO设备低速性,可以将独占设备改为共享设备
    1. 输入井和输出井: 输入井模拟脱机输入时的磁盘,放IO设备输入数据;输出井模拟脱机输出时的磁盘,放用户程序的输出数据
    2. 输入缓冲区和输出缓冲区: 输入缓冲区在内存暂存输入设备设备送来的数据,以后送到输入井.输出设备在内存暂存输出井送来的设备,以后送到输出设备
    3. 输入进程和输出进程:  
        输入进程模拟脱机输入的外围控制机,将用户数据从输入机通过输入缓冲区送到输入井,CPU需要数据则从输入井读入  
        输出进程模拟脱机输出的外围控制机,数据从内存送到输出井,输出设备空闲,输出进程将输出井中的数据通过输出缓冲区送到输出设备  
    4. SPOOLing特点: 提高IO速度,将独占设备改为共享设备,实现虚拟设备
18. 设备独立性优点: 方便用户编程; 程序不受机器环境影响; 便于程序移植
19. 设备分配过程: 
    1. 根据IO请求的物理设备名找到系统设备表(SDT),然后找到设备控制表(DCT),设备忙,进程PCB挂到设备请求队列,不忙则看分配设备安全性,不安全,进程PCB挂到设备请求队列,安全,分配设备,找到控制器控制表(COCT)
    2. 控制器控制表显示设备忙,进程PCB挂到控制器队列,不忙则看分配设备安全性,不安全,进程PCB挂到控制器队列,安全,则分配控制器, 找通道控制表(CHCT)
    3. 通道控制表显示设备忙,进程PCB挂到通道队列,空闲,则分配通道给进程.进程则进行数据传送
20. 设备分配程序改进: 设备分配更灵活,分配成功率更高
    1. 增加设备独立性: 进程用逻辑设备名请求IO,从SDT找到该类设备所有DCT忙, 则将程序PCB挂到该类设备等待队列下,否则计算安全性,安全则分配
    2. 考虑多通路情况: 控制器或通道也有多个,所有的控制器或通道都忙,则将进程PCB挂到等待队列下,否则,计算安全性,安全则分配
    3. 设备分配访问的数据结构: SDT->DCT->DOCT->CHCT.分配一个设备需要设备可用,控制器可用,通道可用
