!> 计算机系统概述

# 书籍链接
* [书籍链接,13](file:///media/deepin/670B-1B04/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B/2021%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.pdf)

# 相关寄存器名词
* MAR: (Memory Address Register)地址寄存器,长度等于PC  
    MAR有10位,则可寻址的存储单元个数就是2<sup>10</sup>=1024 
* MDR: (Memory Data Register)数据寄存器,长度等于存储字长(一般为字节偶数倍)  
* ALU: (Arithmatic Logical Unit)算数逻辑单元
* ACC: (Accumulator)累加器
* MQ: (Multipie-Quotient)乘商寄存器
* X: 操作数寄存器
* IX: 变址寄存器
* BR: (Base Register)基址寄存器
* PSW: (Program Status Word)程序状态寄存器,标志寄存器,存放ALU信息或处理机信息(有无溢出,有无进位,结果正负等)  
* PC: (Program Counter)程序计数器, 存放当前执行指令地址, 取完指令地址则自动加1形成下条指令地址.与MAR有直接通路  
    (PC) + 1 -> PC,(PC)是程序计数器放的内容  
* IR: (Instruction Register)指令寄存器,存放当前指令.指令来自MDR.长度是存储字长的整数倍
    * OP(IR): 指令中的操作码,会送到CU并分析指令发出微操作命令序列
    * Ad(IR): 指令中的地址码,会送到MAR,用来取操作数.IR的Ad长度等于MDR的长度
* CU: (Control Unit)
* GPRs: (Genetic Processing Registers)通用寄存器组,暂存操作数和中间结果

# 计算机发展历程
1. 1946年世界第一台计算机问世(ENIAC)
2. 计算机4个时代
    1. 第一代:(1946-1954)电子管.体积大,成本高,运算速度低(几千到几万次每秒)  
        逻辑元件: 电子管  
        语言: 机器语言  
        主存: 延迟线或磁鼓(容量小)  
    2. 第二代:(1958-1964)晶体管.运算速度较快(几万到几十万次每秒),有了操作系统雏形  
        逻辑元件: 晶体管  
        语言: 开始有高级语言(FORTRAN)  
        主存: 磁心  
    3. 第三代:(1965-1971)中小规模集成电路.高级语言迅速发展,有了分时操作系统  
        逻辑元件: 中小规模集成电路  
        语言: 高级语言  
        主存: 半导体存储器  
    4. 第四代:(1972-今天)超大规模集成电路.  
        逻辑元件: 超大规模集成电路(微处理器,有了并行,流水线,高速缓存,虚拟存储器)  
3. 摩尔定律: 价格不变下,18个月集成电路容纳晶体管数目翻一倍.性能翻一倍
4. 1970年,仙童公司生产出第一个半导体存储器.
5. 1971年,英特尔公司开发出第一个微处理器(第一个只有8位,即一次处理8个二进制位)
6. 机器字长: 一次整数运算所能处理的二进制位数
7. `机器语言`和`汇编语言`都是面向机器的.
8. 电子计算机分为`电子模拟计算机`和`电子数字计算机`
9. 数字计算机分为`专用计算机`和`通用计算机`
10. 通用计算机分为`巨型机`, `大型机`, `中型机`, `小型机`, `微型机`, `单片机`(越大,价格越高,指令系统越复杂)
11. 计算机按指令和数据流分
    1. 单指令流单数据流系统: 传统冯诺依曼体系结构
    2. 单指令流多数据流系统: 阵列处理器和向量处理器系统
    3. 多指令流单数据流系统: 实际不存在
    4. 多指令流多数据流系统: 多处理器和多计算机系统
12. 微型计算机更加微型化,网络化,高性能,多用途,巨型机更巨型化,超高速,并行能力高,更智能

# 计算机系统层次结构
1. 软件包括硬件上运行的程序和相关的数据及文档
2. 软硬件在逻辑上是等效的: 某一个功能既可以由软件实现又可以用硬件实现
    1. 如果一个功能使用频繁,硬件实现成本较理想,则使用硬件实现
    2. 如果一个功能需要灵活性,则用软件实现,但效率低于硬件
3. 冯诺依曼机特点
    1. 由`运算器`, `存储器`, `控制器`, `输入`, `输出设备`5部分组成
    2. `指令`和`数据`以同等地位存储在存储器,可按址访问
    3. `指令`和`数据`都用二进制代码表示
    4. 指令由`操作码`和`地址码`组成.操作码表示操作类型,地址码表示操作数在存储器的位置
    5. 指令在存储器顺序存放.指令通常顺序执行,也可根据运算结果或条件改变执行顺序
    6. 早期冯诺依曼机以`运算器`为中心,IO设备通过运算器与存储器传送数据
4. `存储程序`的思想奠定了现代计算机的基本结构.`存储程序`是将指令以代码形式先存入计算机的存储器,然后从首地址执行.
5. 微处理器问世之前,`运算器和控制器是分离的`, 数据存储量也小,所以运算器为中心.
6. 现代计算机以存储器为中心,使IO操作尽量绕过CPU,直接在IO设备和存储器间完成
7. 计算机的功能部件
    1. 输入设备: 将程序和数据以机器能识别的形式输入计算机
    2. 输出设备: 将计算机处理结果以人们能接受的形式或其他系统要求形式输出  
    3. 存储器: 存放程序和数据.  
        主存由`存储单元`组成,存储单元由`存储元件`组成  
        一个存储元件存一位二进制位.一个存储单元存一串二进制位(`存储字`),一个存储单元存的二进制位个数叫`存储字长`(可以为1B或字节的偶数倍)  
        主存按存储单元地址存取数据(按地址存取),`相联存储器`按内容存取数据(如按字段)   
        `MAR和MDR属于存储器`,但集成在CPU中,cache(高速缓存)也集成在CPU中  
    4. 运算器: 用于`算术运算`(加减乘除)和`逻辑运算`(与,或,非,异或,比较,移位)  
        运算器核心是ALU,还包括很多通用寄存器(ACC, MQ, X, IX, BR,PSW, 前三个必须有)  
    5. 控制器: 指挥各部件工作.由PC,IR,CU组成  
    6. 运算器和控制器集成到一个芯片,成为CPU(Contral Processing Unit,中央处理器)  
        CPU和主存构成主机  
        主机外的其他硬件(外存,IO设备)构成外设  
        CPU通过总线(有地址线,控制线,数据线)与主存相连.  
        MAR地址传到地址线,指向主存存储单元,控制线发出读/写命令,然后将数据线地址传到MDR/将MDR数据传到数据线  
8. 控制信号: 发出控制命令(读信号,写信号,PC如何获取下条地址等)
9. 计算机软件分为`系统软件`和`应用软件`
    系统软件: 保证系统正确使用的基础软件,如操作系统, 数据库管理系统(DBMS),网络软件系统等  
    应用软件: 解决用户各类问题的程序  
10. DBMS(数据库管理系统)是介于用户和操作系统的数据管理软件,是系统软件  
    DBS(数据库系统)是计算机引入数据库后的系统(由数据库,数据库管理系统,数据库管理员DBA,应用系统构成)
11. 三个级别语言
    1. 机器语言: 计算机可以直接识别和执行. 如要手动编写则需记忆指令的二进制编码.
    2. 汇编语言: 用英文单词或缩写代替二进制指令代码. 需要用汇编程序翻译成机器语言,硬件才能执行
    3. 高级语言: (C, C++等)需要由编译程序编译成汇编语言程序,再由汇编程序翻译成机器语言,或直接将高级语言程序翻译成机器语言程序
12. 计算机工作过程
    1. 将程序和数据装入主存
    2. 将源程序转换成可执行文件  
        预处理: 读取源文件(hello.c),去掉文件中注释,插入所需`.h`文件代码生成`hello.i`  
        编译: 将`hello.i`程序编译成汇编语言程序`hello.s`  
        汇编: 将`hello.s`翻译成机器语言指令,并打包成可重定位目标文件`hello.o`  
        链接: 将多个可重定位目标文件和标准库函数合并成可执行文件
    3. 从可执行文件首地址逐条执行指令  
        将程序第一条指令地址放到PC,PC自动加一(取完指令地址则自增).根据PC读取指令到IR,解析IR的OP,Ad,然后执行.  
        执行完后获取下条指令地址  
13. 取数操作的执行流程
    取指令:PC->MAR->M(同时获得读信号)->MDR->IR  
    分析指令: OP(IR) -> CU(通过译码得到控制信号类型)  
    执行指令: Ad(IR) -> MAR -> M ->MDR -> ACC  
14. 计算机系统层次结构
    1. 微程序机器M0(微指令系统): 硬件层,硬件直接执行微指令
    2. 传统机器M1(用机器语言的机器): 硬件层,微程序解释机器指令
    3. 虚拟机器M2(操作系统机器): 软件层,也叫混合层,操作系统有广义指令和机器指令,用机器语言调用操作系统的机器指令
    4. 虚拟机器M3(汇编语言机器): 软件层,用汇编程序翻译成机器语言
    5. 虚拟机器M4(高级语言机器): 软件层,用编译程序编译成汇编语言
    6. 应用层: word,QQ
15. 操作系统机器,汇编语言机器,高级语言机器是虚拟机.虚拟机只对该层观察者存在.
16. 层次之间,下层是上层的基础,上层是下层的扩展.
17. 软硬件交界面的划分不绝对,只要用的多,硬件成本不高,由软件实现的功能也可以由硬件实现.
18. 几个术语
    1. 系列机: 体系结构基本相同, 基本指令系统相同的多个不同型号的计算机产品系列
    2. 兼容: 计算机软件或硬件通用性.
    3. 软件可移植性: 某个系列计算机的软件直接或少量修改就可以运行在另一个系列计算机的可能性
    4. 固件: 将程序固定在ROM中组成的部件,是一种有软件特性的硬件.固件介于软硬件,比软件执行快,比硬件灵活.如把软件放到只读存储器
19. CPU中,IR,MAR,MDR对各类程序员都透明(看不见)
20. 编译程序和汇编程序
    1. 翻译程序: 将高级语言源程序翻译成机器语言程序(目标程序),包括`编译程序`和`解释程序`
        1. 编译程序: 将高级语言源程序一次全部翻译成机器语言,会生成目标程序.同一高级语言在不同体系结构下编译成的机器语言不同
        2. 解释程序: 将高级语言源程序一句一句翻译成机器语言,并立即执行,不会生成目标程序
    2. 汇编程序: 将汇编语言源程序翻译成机器语言程序,与机器语言一一对应.
    3. 将高级语言翻译成汇编语言或机器语言的翻译程序叫`编译程序`,将汇编语言翻译成机器语言的程序叫`汇编程序`
21. 机器字长,指令字长,存储字长都是字节整数倍.指令字长是存储字长整数倍
22. 64位机器可以使用64位操作系统,也可以使用32位操作系统,32位操作系统不能使用64位操作系统



# 计算机性能指标
1. 机器字长: 计算机一次整数运算所能处理的二进制数据位数,一般等于内部寄存器(加法器等)位数,决定了计算机运算精度.  
    一般为字节的偶数倍  
2. 数据通路带宽: 数据总线一次并行传送信息位数  
    这里指外部数据总线宽度,与CPU内部数据总线宽度(内部寄存器大小)可能不同  
    数据通路: 各个子系统通过数据总线连接成的数据传送路径  
3. 主存容量: 主存最大容量,单位为`字节`或`字数x字长`  
    从MAR位数可以得到主存存储单元个数,也可得最大寻址范围
4. 运算速度
    1. 吞吐量: 单位时间内处理请求数量.取决于主存存取周期
    2. 响应时间: 用户给计算机发送请求到计算机响应的等待时间(等于CPU时间+等待时间(磁盘访问,主存访问,IO操作,操作系统开销等时间))
    3. 主频: CPU时钟频率, 机器内部主时钟频率.同型号计算机,主频越高,执行一个指令时间越短.  
    ```tex
    \displaystyle
    \small
    CPU时钟周期 = \frac{1}{主频}  \\
    主频的单位是赫兹(Hz), 1Hz就是每秒一次  \\
    ```
    4. CPU时钟周期: 为`节拍脉冲`或`T周期`,主频倒数,CPU最小时间单位,每个动作至少一个时钟周期
    5. CPI(Clock cycle Per Instruction): 一条指令的时钟周期数
    6. CPU执行时间: 运行一个程序花费时间  
    ```tex
    CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{CPI x 指令条数}{主频}  \\
    由此看出,CPI,主频, 指令条数相互制约  \\
    ```  
    7. 一些缩写
    ```tex
    \displaystyle
    \small
    MIPS: (Million Instructions Per Second),每秒执行几百万条指令  \\
    MIPS = \frac{指令数}{执行时间 x 10^6} = \frac{主频}{CPI}  \\
    MFLOPS: (Mega Floating-point Operations Per Second), 每秒执行几百万次浮点操作  \\
    MFLOPS = \frac{浮点操作次数}{执行时间 x 10^6}  \\
    GFLOPS: (Giga Floating-point Operations Per Second), 每秒执行几十亿次浮点操作  \\
    GFLOPS = \frac{浮点操作次数}{执行时间 x 10^9}  \\
    TFLOPS: (Tera Floating-point Operations Per Second), 每秒执行几万亿次浮点操作  \\
    TFLOPS = \frac{浮点操作次数}{执行时间 x 10^{12}}  \\
    容量用2^n,用K,速率,频率用10^n,用k
    ```
5. 主频高,指令执行快,但CPU运行还受指令集,CPU位数等影响,故可能主频高,CPU运算低.